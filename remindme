#!/usr/bin/env bash
set -euo pipefail

STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/remindme-cli"
JOBS_DIR="$STATE_DIR/jobs"
PID_FILE="$STATE_DIR/daemon.pid"
LOG_FILE="$STATE_DIR/daemon.log"
ENV_FILE="$STATE_DIR/env.sh"
SLEEP_PID=""

usage() {
  cat <<'EOF'
Usage:
  remindme start
  remindme stop
  remindme status
  remindme list
  remindme snooze <id> <delay>
  remindme pause <id>
  remindme resume <id>
  remindme remove <id>
  remindme clear
  remindme add <delay> <message...>
  remindme add --at "YYYY-MM-DD HH:MM[:SS]" <message...>
  remindme every <interval> <message...>

Shortcuts (same as "add"):
  remindme <delay> <message...>
  remindme --at "YYYY-MM-DD HH:MM[:SS]" <message...>

Examples:
  remindme start
  remindme 10m Stretch and drink water
  remindme add 1h30m Start laundry
  remindme every 30m Drink water
  remindme --at "2026-02-24 18:30" Join standup
  remindme list
  remindme snooze 1771961521-123 10m
  remindme pause 1771961521-124
  remindme resume 1771961521-124

Environment (captured when you run start/add/every):
  DISCORD_WEBHOOK_URL   Optional Discord webhook URL
  DISPLAY / DBUS_SESSION_BUS_ADDRESS / WAYLAND_DISPLAY / XDG_RUNTIME_DIR
EOF
}

err() {
  printf 'Error: %s\n' "$*" >&2
  exit 1
}

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

ensure_state_dirs() {
  mkdir -p "$JOBS_DIR"
}

write_env_file() {
  ensure_state_dirs
  {
    printf '# Auto-generated by remindme\n'
    for v in DISCORD_WEBHOOK_URL DISPLAY DBUS_SESSION_BUS_ADDRESS WAYLAND_DISPLAY XDG_RUNTIME_DIR; do
      if [[ -n "${!v-}" ]]; then
        printf 'export %s=%q\n' "$v" "${!v}"
      fi
    done
  } >"$ENV_FILE"
}

load_env_file() {
  if [[ -f "$ENV_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$ENV_FILE"
  fi
}

parse_delay_seconds() {
  local input="${1:-}"

  if [[ "$input" =~ ^[0-9]+$ ]]; then
    printf '%s\n' "$input"
    return 0
  fi

  local rest="$input"
  local total=0
  while [[ -n "$rest" ]]; do
    if [[ "$rest" =~ ^([0-9]+)([smhd])(.*)$ ]]; then
      local n="${BASH_REMATCH[1]}"
      local unit="${BASH_REMATCH[2]}"
      rest="${BASH_REMATCH[3]}"
      case "$unit" in
        s) total=$((total + n)) ;;
        m) total=$((total + n * 60)) ;;
        h) total=$((total + n * 3600)) ;;
        d) total=$((total + n * 86400)) ;;
      esac
    else
      return 1
    fi
  done
  printf '%s\n' "$total"
}

epoch_from_datetime() {
  local target="$1"
  if ! date -d "$target" +%s 2>/dev/null; then
    return 1
  fi
}

is_running() {
  [[ -f "$PID_FILE" ]] || return 1
  local pid
  pid="$(cat "$PID_FILE" 2>/dev/null || true)"
  [[ "$pid" =~ ^[0-9]+$ ]] || return 1
  kill -0 "$pid" 2>/dev/null
}

daemon_pid() {
  cat "$PID_FILE"
}

notify_local() {
  local msg="$1"
  if have_cmd notify-send; then
    notify-send "Reminder" "$msg" || true
  fi
}

notify_discord() {
  local msg="$1"
  local webhook="${DISCORD_WEBHOOK_URL:-}"
  [[ -n "$webhook" ]] || return 0
  if ! have_cmd curl; then
    printf 'Warning: curl not found; skipping Discord notification\n' >&2
    return 0
  fi

  local escaped
  escaped="$(printf '%s' "$msg" | sed 's/\\/\\\\/g; s/"/\\"/g')"
  curl -sS -X POST "$webhook" \
    -H 'Content-Type: application/json' \
    -d "{\"content\":\"Reminder: ${escaped}\"}" >/dev/null || true
}

send_reminder() {
  local msg="$1"
  printf '\a' >&2
  printf '\n[%s] Reminder: %s\n' "$(date '+%F %T')" "$msg" >&2
  notify_local "$msg"
  notify_discord "$msg"
}

job_create() {
  local due_epoch="$1"
  local msg="$2"
  local repeat_seconds="${3:-0}"
  local paused="${4:-0}"
  ensure_state_dirs

  local now uniq file
  now="$(date +%s)"
  uniq="$(date +%s%N 2>/dev/null || printf '%s-%s' "$now" "$RANDOM")"
  file="$JOBS_DIR/${due_epoch}-${uniq}.job"

  msg="${msg//$'\n'/ }"
  {
    printf '%s\n' "$due_epoch"
    printf '%s\n' "$now"
    printf '%s\n' "$msg"
    printf '%s\n' "$repeat_seconds"
    printf '%s\n' "$paused"
  } >"$file"

  printf '%s\n' "$file"
}

job_read_field() {
  local file="$1" line_no="$2"
  sed -n "${line_no}p" "$file"
}

job_due_epoch() {
  job_read_field "$1" 1
}

job_message() {
  job_read_field "$1" 3
}

job_repeat_seconds() {
  local repeat
  repeat="$(job_read_field "$1" 4 2>/dev/null || true)"
  if [[ "$repeat" =~ ^[0-9]+$ ]]; then
    printf '%s\n' "$repeat"
  else
    printf '0\n'
  fi
}

job_paused() {
  local paused
  paused="$(job_read_field "$1" 5 2>/dev/null || true)"
  if [[ "$paused" =~ ^[01]$ ]]; then
    printf '%s\n' "$paused"
  else
    printf '0\n'
  fi
}

job_id_from_path() {
  basename "$1" .job
}

job_path_from_id() {
  printf '%s/%s.job\n' "$JOBS_DIR" "$1"
}

job_update() {
  local file="$1"
  local due_epoch="$2"
  local msg="$3"
  local repeat_seconds="$4"
  local paused="${5:-0}"
  local tmp
  tmp="$(mktemp)"
  msg="${msg//$'\n'/ }"
  {
    printf '%s\n' "$due_epoch"
    printf '%s\n' "$(date +%s)"
    printf '%s\n' "$msg"
    printf '%s\n' "$repeat_seconds"
    printf '%s\n' "$paused"
  } >"$tmp"
  mv "$tmp" "$file"
}

job_read_all() {
  local file="$1"
  local due msg repeat paused
  due="$(job_due_epoch "$file" 2>/dev/null || true)"
  msg="$(job_message "$file" 2>/dev/null || true)"
  repeat="$(job_repeat_seconds "$file" 2>/dev/null || printf '0\n')"
  paused="$(job_paused "$file" 2>/dev/null || printf '0\n')"
  printf '%s\t%s\t%s\t%s\n' "$due" "$msg" "$repeat" "$paused"
}

daemon_process_jobs() {
  local now next_due="" file due msg repeat paused next_run
  now="$(date +%s)"

  shopt -s nullglob
  for file in "$JOBS_DIR"/*.job; do
    due="$(job_due_epoch "$file" 2>/dev/null || true)"
    [[ "$due" =~ ^[0-9]+$ ]] || { rm -f "$file"; continue; }
    paused="$(job_paused "$file" 2>/dev/null || printf '0\n')"
    if [[ "$paused" == "1" ]]; then
      continue
    fi
    if (( due <= now )); then
      msg="$(job_message "$file" 2>/dev/null || true)"
      repeat="$(job_repeat_seconds "$file" 2>/dev/null || printf '0\n')"
      rm -f "$file"
      if [[ "$repeat" =~ ^[0-9]+$ ]] && (( repeat > 0 )); then
        next_run=$((now + repeat))
        job_create "$next_run" "$msg" "$repeat" 0 >/dev/null
      fi
      send_reminder "$msg"
    else
      if [[ -z "$next_due" || "$due" -lt "$next_due" ]]; then
        next_due="$due"
      fi
    fi
  done
  shopt -u nullglob

  if [[ -n "$next_due" ]]; then
    printf '%s\n' "$next_due"
  fi
}

daemon_loop() {
  ensure_state_dirs
  load_env_file

  if is_running; then
    printf 'Daemon already running (pid %s)\n' "$(daemon_pid)" >&2
    exit 1
  fi

  printf '%s\n' "$$" >"$PID_FILE"
  trap 'rm -f "$PID_FILE"; exit 0' INT TERM EXIT
  trap 'if [[ -n "${SLEEP_PID:-}" ]]; then kill "$SLEEP_PID" 2>/dev/null || true; fi' USR1

  printf '[%s] daemon started pid=%s\n' "$(date '+%F %T')" "$$" >>"$LOG_FILE"

  while true; do
    load_env_file
    local next_due now sleep_for
    next_due="$(daemon_process_jobs || true)"
    if [[ -n "$next_due" && ! "$next_due" =~ ^[0-9]+$ ]]; then
      next_due=""
    fi
    now="$(date +%s)"

    if [[ -z "$next_due" ]]; then
      sleep_for=5
    else
      sleep_for=$((next_due - now))
      if (( sleep_for < 1 )); then
        sleep_for=1
      elif (( sleep_for > 5 )); then
        sleep_for=5
      fi
    fi

    sleep "$sleep_for" &
    SLEEP_PID="$!"
    wait "$SLEEP_PID" || true
    SLEEP_PID=""
  done
}

daemon_start() {
  ensure_state_dirs
  if is_running; then
    printf 'Daemon already running (pid %s)\n' "$(daemon_pid)"
    return 0
  fi

  write_env_file
  nohup "$0" __daemon >/dev/null 2>>"$LOG_FILE" &
  sleep 0.2

  if is_running; then
    printf 'Daemon started (pid %s)\n' "$(daemon_pid)"
  else
    err "Failed to start daemon (see $LOG_FILE)"
  fi
}

daemon_stop() {
  if ! is_running; then
    printf 'Daemon is not running\n'
    rm -f "$PID_FILE"
    return 0
  fi

  local pid
  pid="$(daemon_pid)"
  kill "$pid" 2>/dev/null || true
  sleep 0.2
  if kill -0 "$pid" 2>/dev/null; then
    printf 'Daemon pid %s did not stop yet\n' "$pid"
    return 1
  fi
  rm -f "$PID_FILE"
  printf 'Daemon stopped\n'
}

daemon_status() {
  if is_running; then
  local pid count
    pid="$(daemon_pid)"
    count="$(find "$JOBS_DIR" -maxdepth 1 -name '*.job' 2>/dev/null | wc -l | tr -d ' ')"
    printf 'running pid=%s queued=%s\n' "$pid" "$count"
  else
    printf 'stopped\n'
  fi
}

daemon_wake() {
  if is_running; then
    kill -USR1 "$(daemon_pid)" 2>/dev/null || true
  fi
}

cmd_add() {
  [[ $# -ge 2 ]] || err "Expected: remindme add <delay> <message...>"

  local due_epoch msg seconds now target_human

  if [[ "${1:-}" == "--at" ]]; then
    [[ $# -ge 3 ]] || err "Expected: remindme add --at \"YYYY-MM-DD HH:MM\" <message...>"
    if ! due_epoch="$(epoch_from_datetime "$2")"; then
      err "Invalid datetime format: $2"
    fi
    now="$(date +%s)"
    (( due_epoch >= now )) || err "Target time is in the past: $2"
    shift 2
  else
    seconds="$(parse_delay_seconds "$1")" || err "Invalid delay '$1' (use e.g. 30s, 10m, 1h30m)"
    shift
    now="$(date +%s)"
    due_epoch=$((now + seconds))
  fi

  msg="$*"
  [[ -n "$msg" ]] || err "Message cannot be empty"

  write_env_file
  job_create "$due_epoch" "$msg" 0 >/dev/null
  daemon_wake

  target_human="$(date -d "@$due_epoch" '+%F %T')"
  printf 'Queued reminder for %s: %s\n' "$target_human" "$msg"

  if ! is_running; then
    printf 'Note: daemon is not running. Start it with: remindme start\n' >&2
  fi
}

cmd_every() {
  [[ $# -ge 2 ]] || err "Expected: remindme every <interval> <message...>"
  local interval msg now due_epoch target_human
  interval="$(parse_delay_seconds "$1")" || err "Invalid interval '$1' (use e.g. 30s, 10m, 1h)"
  (( interval > 0 )) || err "Interval must be > 0"
  shift
  msg="$*"
  [[ -n "$msg" ]] || err "Message cannot be empty"

  now="$(date +%s)"
  due_epoch=$((now + interval))

  write_env_file
  job_create "$due_epoch" "$msg" "$interval" >/dev/null
  daemon_wake

  target_human="$(date -d "@$due_epoch" '+%F %T')"
  printf 'Queued recurring reminder every %ss (next %s): %s\n' "$interval" "$target_human" "$msg"

  if ! is_running; then
    printf 'Note: daemon is not running. Start it with: remindme start\n' >&2
  fi
}

cmd_list() {
  ensure_state_dirs
  shopt -s nullglob
  local files=("$JOBS_DIR"/*.job)
  shopt -u nullglob

  if (( ${#files[@]} == 0 )); then
    printf 'No queued reminders\n'
    return 0
  fi

  local tmp file due msg now remaining repeat paused id type
  tmp="$(mktemp)"
  now="$(date +%s)"

  for file in "${files[@]}"; do
    due="$(job_due_epoch "$file" 2>/dev/null || true)"
    msg="$(job_message "$file" 2>/dev/null || true)"
    repeat="$(job_repeat_seconds "$file" 2>/dev/null || printf '0\n')"
    paused="$(job_paused "$file" 2>/dev/null || printf '0\n')"
    id="$(job_id_from_path "$file")"
    [[ "$due" =~ ^[0-9]+$ ]] || continue
    remaining=$((due - now))
    if (( repeat > 0 )); then
      type="every:${repeat}s"
    else
      type="once"
    fi
    if [[ "$paused" == "1" ]]; then
      type="${type},paused"
    fi
    printf '%s\t%s\t%s\t%s\t%s\n' "$due" "$id" "$remaining" "$type" "$msg" >>"$tmp"
  done

  sort -n "$tmp" | while IFS=$'\t' read -r due id remaining type msg; do
    printf '%s  id=%s  (%ss)  [%s]  %s\n' "$(date -d "@$due" '+%F %T')" "$id" "$remaining" "$type" "$msg"
  done
  rm -f "$tmp"
}

cmd_snooze() {
  [[ $# -eq 2 ]] || err "Expected: remindme snooze <id> <delay>"
  ensure_state_dirs
  local id delay file due msg repeat paused delta now new_due
  id="$1"
  delay="$2"
  file="$(job_path_from_id "$id")"
  [[ -f "$file" ]] || err "No reminder with id '$id'"
  delta="$(parse_delay_seconds "$delay")" || err "Invalid delay '$delay'"
  (( delta > 0 )) || err "Delay must be > 0"
  IFS=$'\t' read -r due msg repeat paused < <(job_read_all "$file")
  now="$(date +%s)"
  new_due=$((now + delta))
  job_update "$file" "$new_due" "$msg" "$repeat" "$paused"
  daemon_wake
  printf 'Snoozed %s until %s\n' "$id" "$(date -d "@$new_due" '+%F %T')"
}

cmd_pause() {
  [[ $# -eq 1 ]] || err "Expected: remindme pause <id>"
  ensure_state_dirs
  local id file due msg repeat paused
  id="$1"
  file="$(job_path_from_id "$id")"
  [[ -f "$file" ]] || err "No reminder with id '$id'"
  IFS=$'\t' read -r due msg repeat paused < <(job_read_all "$file")
  (( repeat > 0 )) || err "pause only supports recurring reminders"
  [[ "$paused" == "1" ]] && { printf 'Reminder %s is already paused\n' "$id"; return 0; }
  job_update "$file" "$due" "$msg" "$repeat" 1
  daemon_wake
  printf 'Paused recurring reminder %s\n' "$id"
}

cmd_resume() {
  [[ $# -eq 1 ]] || err "Expected: remindme resume <id>"
  ensure_state_dirs
  local id file due msg repeat paused now new_due
  id="$1"
  file="$(job_path_from_id "$id")"
  [[ -f "$file" ]] || err "No reminder with id '$id'"
  IFS=$'\t' read -r due msg repeat paused < <(job_read_all "$file")
  (( repeat > 0 )) || err "resume only supports recurring reminders"
  if [[ "$paused" != "1" ]]; then
    printf 'Reminder %s is not paused\n' "$id"
    return 0
  fi
  now="$(date +%s)"
  new_due="$due"
  if (( new_due <= now )); then
    new_due=$((now + repeat))
  fi
  job_update "$file" "$new_due" "$msg" "$repeat" 0
  daemon_wake
  printf 'Resumed recurring reminder %s (next %s)\n' "$id" "$(date -d "@$new_due" '+%F %T')"
}

cmd_remove() {
  [[ $# -eq 1 ]] || err "Expected: remindme remove <id>"
  ensure_state_dirs
  local id file
  id="$1"
  file="$(job_path_from_id "$id")"
  if [[ ! -f "$file" ]]; then
    err "No reminder with id '$id'"
  fi
  rm -f "$file"
  daemon_wake
  printf 'Removed reminder %s\n' "$id"
}

cmd_clear() {
  ensure_state_dirs
  shopt -s nullglob
  local files=("$JOBS_DIR"/*.job)
  shopt -u nullglob
  if (( ${#files[@]} == 0 )); then
    printf 'No queued reminders\n'
    return 0
  fi
  rm -f "${files[@]}"
  daemon_wake
  printf 'Cleared %s reminder(s)\n' "${#files[@]}"
}

main() {
  [[ $# -gt 0 ]] || { usage; exit 1; }

  case "${1:-}" in
    -h|--help)
      usage
      ;;
    __daemon)
      daemon_loop
      ;;
    start)
      daemon_start
      ;;
    stop)
      daemon_stop
      ;;
    status)
      daemon_status
      ;;
    list)
      cmd_list
      ;;
    snooze)
      shift
      cmd_snooze "$@"
      ;;
    pause)
      shift
      cmd_pause "$@"
      ;;
    resume)
      shift
      cmd_resume "$@"
      ;;
    remove)
      shift
      cmd_remove "$@"
      ;;
    clear)
      cmd_clear
      ;;
    add)
      shift
      cmd_add "$@"
      ;;
    every)
      shift
      cmd_every "$@"
      ;;
    --at)
      cmd_add "$@"
      ;;
    *)
      if [[ "${1:-}" =~ ^[0-9]+([smhd][0-9]*)*([smhd])?$ || "${1:-}" =~ ^[0-9]+$ ]]; then
        cmd_add "$@"
      else
        err "Unknown command '$1' (use --help)"
      fi
      ;;
  esac
}

main "$@"
